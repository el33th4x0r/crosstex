#! /usr/bin/env python
#
# CROSSTEX: This is a new, object-oriented cross-referencing engine, to
#         replace BIBTEX.
#
# (c) August 2006, Emin Gun Sirer
# Distributed under the GNU Public License, v2
# See the file COPYING for copyright info
#
#         Features:
#         Object-oriented: Need only enter conference, workshop, venue, etc
#            information once, no need to reenter everything under every descriptor
#            as is required in the relational bibtex model
#         Can generate short or long form references: Suitable for the space crunch as well
#            as formal, long-form references.
#         Capitalization works: Things get capitalized the way they appear in the references.
#         Include files: A bibliography can be broken up into modular units.
#         Sanity checking: Running crosstex on a bib/xtx file will check all entries for conformance.
#         Supports entries with multiple keys, e.g. @book{x=y=z, author=...}
#         Backwards compatible with bibtex
#         Can generate bibtex output: if you must use a bibtex style file, you can
#
version = 'Testing'
xtxlib = '.'
plylib = '/usr/local/lib/crosstex'

import sys
sys.path.append(xtxlib)
if plylib not in sys.path:
    sys.path.append(plylib)

import ply.lex as lex
import ply.yacc as yacc

import copy
import math
import pipes
import re
import optparse
import string
import tempfile

import crosstexobjects


# Pre-defined styles.

styles = {
    'abbrv': ['--no-break-lines', '--no-blank-labels', '--no-title-head', '--no-abstract', '--no-keywords', '--short', 'author', '--cite-by', 'initials'],
    'alpha': ['--no-break-lines', '--no-blank-labels', '--no-title-head', '--no-abstract', '--no-keywords', '--cite-by', 'initials'],
    'full': ['--no-break-lines', '--no-blank-labels', '--no-title-head', '--no-abstract', '--no-keywords', '--cite-by', 'fullname', '--add-proceedings', '--add-in'],
    'unsrt': ['--no-break-lines', '--no-blank-labels', '--no-title-head', '--no-abstract', '--no-keywords', '--cite-by', 'number', '--no-sort'],
    'plain': ['--no-break-lines', '--no-blank-labels', '--no-title-head', '--no-abstract', '--no-keywords', '--cite-by', 'number'],
    'html': ['-l', 'Abstract', '-l', 'URL', '-l', 'PS', '-l', 'PDF', '-l', 'HTML', '-l', 'DVI', '-l', 'TeX', '-l', 'Bib', '-l', 'FTP', '-l', 'HTTP', '-l', 'RTF', '--break-lines', '--blank-labels', '--title-head', '--abstract', '--keywords'],
}


# Set up options.

optparser = optparse.OptionParser(usage="usage: %prog [options] files", version="CrossTeX %s" % version, description="A modern, object-oriented bibliographic tool intended to replace BibTeX.")

def optstyle(option, opt, value, parser):
    global styles
    for i in range(len(styles[value])):
        parser.rargs.insert(i, styles[value][i])

def optheading(option, opt, value, parser, reversed=False):
    parser.values.heading.append((reversed, value))
    parser.values.headinglevel += 1

def optsort(option, opt, value, parser, reversed=False):
    if parser.values.sort == None or value == 'none':
	parser.values.sort = []
    parser.values.sort.append((reversed, value))

def optconvert(option, opt, value, parser):
    global styles
    parser.values.convert = opt[6:]
    if opt[6:] in styles:
        for i in range(len(styles[opt[6:]])):
            parser.rargs.insert(i, styles[opt[6:]][i])

optparser.add_option('-d', '--dir', type='string', action='append', help="Add a directory in which to find data files, searched from last specified to first. Default: %default")
optparser.add_option('--quiet', action='store_const', const=0, dest='check', help="Do not sanity check the input.")
optparser.add_option('--strict', action='store_const', const=2, dest='check', help="Apply stricter checks.")
optparser.add_option('--dump', metavar='TYPE', type='choice', choices=['file', 'titlephrase']+[ name for name in dir(crosstexobjects) if isinstance(getattr(crosstexobjects, name), type) and issubclass(getattr(crosstexobjects, name), crosstexobjects.bibobject) ], action='append', help="After parsing the bibliography, dump a list of all objects of the type specified, or, with \"file\", print a list of files processed.")

optparser.add_option('--cite', type='string', action='append', help="Cite a key exactly as with the \\cite LaTeX command.")
optparser.add_option('-l', '--link', metavar='FIELD', type='string', action='append', help="Add to the list of fields used to generate links. LaTeX documents should make use of links by including the hyperref package. When converting to html, this defaults to [Abstract, URL, PS, PDF, HTML, DVI, TEX, BIB, FTP, HTTP, and RTF].")
optparser.add_option('--no-link', action='store_const', const=[], dest='link')

optparser.add_option('--cite-by', type='choice', choices=['number', 'initials', 'fullname'], help="With \"number\", use numeric labels such as [1]. With \"initials\", use labels based on author last-names such as [SBRD04b]. With \"fullname\", use labels based on author names such as [Sirer et al. 2004].")
optparser.add_option('--style', metavar='STYLE', type='choice', choices=styles.keys(), action='callback', callback=optstyle, help="Use a standard style such as plain, unsrt, abbrv, full, or alpha.  Options set by the style may be overidden by further command-line options.")

optparser.add_option('-s', '--sort', metavar='FIELD', type='string', action='callback', callback=optsort, help="Sort by specified field. Multiple sort orders are applied in the order specified, e.g. \"-s year -s author\" will cause elements to be grouped primarily by author and sub-grouped by year.")
optparser.add_option('-S', '--reverse-sort', metavar='FIELD', type='string', action='callback', callback=optsort, callback_args=(True,), help="Exactly as --sort, but sort by descending field values rather than ascending.")
optparser.add_option('--no-sort', action='store_const', const=[], dest='sort')

optparser.add_option('--heading', metavar='FIELD', type='string', action='callback', callback=optheading, help="Divide entries and create headings in bibliography by the value of the given field.")
optparser.add_option('--reverse-heading', metavar='FIELD', type='string', action='callback', callback=optheading, callback_args=(True,), help="Divide entries and create headings in bibliography by the value of the given field.")

optparser.add_option('--short', metavar='TYPE', type='choice', choices=[ name for name in dir(crosstexobjects) if isinstance(getattr(crosstexobjects, name), type) and issubclass(getattr(crosstexobjects, name), crosstexobjects.string) ], action='append', help="Specify any string-like object, i.e. one with name and shortname fields. Whenever possible, the short name will be used, e.g. two-letter state codes for \"state\", conference acronyms such as NSDI for \"conference\", or initials such as E. G. Sirer for \"author\".")
optparser.add_option('--capitalize', metavar='TYPE', type='choice', choices=[ name for name in dir(crosstexobjects) if isinstance(getattr(crosstexobjects, name), type) and issubclass(getattr(crosstexobjects, name), crosstexobjects.string) ], action='append', help="Specify any string-like object, i.e. one with name and shortname fields. Strings of the specified types will appear in ALL CAPS.")

optparser.add_option('--add-in', action='store_const', const='In', dest='in_str', help="Add \"In\" for articles.")
optparser.add_option('--add-proc', action='store_const', const='Proc. of', dest='proceedings_str', help="Add \"Proc. of\" for conference and workshop publications.")
optparser.add_option('--add-proceedings', action='store_const', const='Proceedings of the', dest='proceedings_str', help="Add \"Proceedings of the\" for conference and workshop publications.")
optparser.add_option('--abstract', action='store_true', help="In the bibliography, include paper abstracts if available.")
optparser.add_option('--no-abstract', action='store_false', dest='abstract')
optparser.add_option('--keywords', action='store_true', help="In the bibliography, include paper keywords if available.")
optparser.add_option('--no-keywords', action='store_false', dest='keywords')
optparser.add_option('--titlecase', type='choice', choices=['lower', 'upper', 'as-is', 'default'], help="In the bibliography, force titles into lower-, upper-, or title-case.  Default: Leave titles unchanged.")
optparser.add_option('--title-head', action='store_true', help="In the bibliography, put the title bold and first.")
optparser.add_option('--no-title-head', action='store_false', dest='title_head')
optparser.add_option('--blank-labels', action='store_true', help="In the bibliography, leave out item labels.")
optparser.add_option('--no-blank-labels', action='store_false', dest='blank_labels')
optparser.add_option('--break-lines', action='store_true', help="In the bibliography, put author, title, and publication information on separate lines.")
optparser.add_option('--no-break-lines', action='store_false', dest='break_lines')
optparser.add_option('--last-first', action='store_true', help="The first name in each author list will appear 'Last, First' instead of 'First Last' (the latter is the default).")
optparser.add_option('--no-last-first', action='store_false', dest='last_first')

optparser.add_option('--xtx2bib', action='callback', callback=optconvert, help="Convert the bibliography information to old-style BibTeX.")
optparser.add_option('--xtx2html', action='callback', callback=optconvert, help="Format the bibliography as HTML.")
optparser.add_option('--bib2xtx', action='callback', callback=optconvert, help="Format the bibliography as HTML.")


# A self-contained bibliographic environment.

def tryint(x):
    try:
	return int(str(x))
    except ValueError:
	return x

class bibliography(dict):

    def __init__(self):
        self.optlist = []
        self.primarykeys = []
        self.aliases = {}
        self.preambles = []
        self.seenfiles = []
        self.titlephrases = {}
        self.titlesmall = {}
        self.punctuation = re.compile('.*([:!.?]|-{2,})$')
        self._citations = None
        self.location = []
	self.errors = 0
    
    def addtitlephrase(self, phrase):
        self.titlephrases[re.sub(r'([\[\]^$*+?{\\|()])', r'\\\1', phrase.lower())] = phrase
    
    def addtitlesmall(self, phrase):
        self.titlesmall[re.sub(r'([\[\]^$*+?{\\|()])', r'\\\1', phrase.lower())] = phrase
        
    def specialres(self):
        return '|'.join([ r'\b' + re.sub(r'([\[\]^$*+?{\\|()])', r'\\\1', phrase.lower()) + r'\b' for phrase in self.titlephrases.keys() + self.titlesmall.keys() ])

    def titlecase(self, title, case, usespecial=True, atstart=True):
        if len(title) >= 3 and title[0] == "{" and title[-1] == "}" and title[-2] != "\\":
            title = title[1:-1]
        newtitle = ''
        needscaps = atstart
        nestingdepth = 0
        wordrestr = r'(-+|\s+|\\\w+|\\\W+|\$[^\$]*\$|[{}]|'
        if usespecial:
            wordrestr += '|' + self.specialres()
        wordrestr += ')'
        wordre = re.compile(wordrestr, re.IGNORECASE)
        specialre = re.compile(r'^(\\.*|\$[^\$]*\$)$')
        spacere = re.compile(r'^\s*$')
        for word in wordre.split(title):
            if word == '{':
                nestingdepth += 1
                needscaps = False
            elif word == '}':
                nestingdepth -= 1
                needscaps = False
            elif spacere.match(word) or word == '-':
                pass
            elif specialre.match(word) or (case != 'upper' and not word.islower() and not word.istitle() and len(word) > 1):
                needscaps = self.punctuation.match(word)
            else: # if nestingdepth == 0
                lowerword = word.lower()
                oldword = word
                if usespecial and lowerword in self.titlephrases:
                    word = self.titlephrases[lowerword]
                elif case == 'upper':
                    word = word.upper()
                elif needscaps:
                    word = word.title()
                elif usespecial and lowerword in self.titlesmall:
                    word = self.titlesmall[lowerword]
                elif case == 'default':
                    word = word.title()
                else:
                    word = lowerword
                needscaps = self.punctuation.match(word)
            atstart = False
            newtitle += word
        return newtitle

    def setoptions(self, optlist):
	global optparser
	self.optlist = optlist + self.optlist
	optparser.set_defaults(
	    check=1,
	    cite=[],
	    cite_by='number',
	    convert='bbl',
	    dir=[xtxlib, '.'],
	    dump=[],
	    heading=[],
	    headinglevel=0,
	    headingdepth=0,
	    in_str='',
	    link=[],
	    proceedings_str='',
	    short=[],
	    capitalize=[],
	    sort=[(False, 'monthno'), (False, 'year'), (False, 'author'), (False, 'label')],
	    titlecase='default',
	)
	(self.options, args) = optparser.parse_args(args=self.optlist)
	self.options.dir.reverse()
	self._citations = None
	return args

    def citations(self):
	if self._citations != None:
	    return self._citations
	self._citations = []

	for key in self.options.cite:
	    if key == '*':
		for key in self.primarykeys:
		    if hasattr(self[key], '_label') and self[key]._citekey == None:
			self[key]._citekey = key
			self._citations.append(key)
	    else:
                # a leading ! indicates that the citation key
                # specifies a set of nbibtex-style constraints.
                # constraints are of the form field=value, but
                # default to author for first field, title for
                # second, and year for third.
                if key[0] == "!":
                    try:
                        def cspec_splitter(x):
                            if x.find("=") > 0:
                                fields = x.split("=")
                                return [fields[0], fields[1].split("-")]
                            else:
                                return ["", x.split("-")]
                        cspec = map(cspec_splitter, string.split(key[1:].lower(), ":"))
                        # fill in defaults
                        if len(cspec) > 0 and cspec[0][0] == '':
                            cspec[0][0] = "author"
                        if len(cspec) > 1 and cspec[1][0] == '':
                            if int(cspec[1][1][0]) > 0:
                                cspec[1][0] = "year"
                            else:
                                cspec[1][0] = "title"
                        if len(cspec) > 2 and cspec[2][0] == "":
                            cspec[2][0] = "year"

                        # check to make sure that constraint specification is not just "!"
                        if len(cspec) == 0:
                                self.error("crosstex: citation constraint <%s> is missing a value constraint" % key)
                                raise Exception("missing field in constrained citation")
                        # check for underspecified constraints -- missing fieldname
                        for constraint in cspec:
                            if constraint[0] == '':
                                self.error("crosstex: citation constraint <%s> is missing a field qualifier" % key)
                                raise Exception("missing fieldname in constrained citation")
                        # check for underspecified constraints -- missing value
                        for constraint in cspec:
                            if constraint[1] == ['']:
                                self.error("crosstex: citation constraint <%s> is missing a value constraint" % key)
                                raise Exception("missing value in constrained citation")
                    except:
                        continue
                    # at this point, we have all the constraints on the citation
                    # cspec = [['author', ['sirer']], ['title', ['sharp', 'hybrid']]]
                    match = None
                    # look through all objects for all matching citations, we'll cite it if the citation is unique
                    for objkey in self.primarykeys:
                        try:
                            # only cite citeable objects
                            if not hasattr(self[objkey], '_label'):
                                continue
                            # go through all constraints
                            for (fieldname, values) in cspec:
                                # check if constrained field exists
                                if hasattr(self[objkey], fieldname):
                                    fieldvalue = str(getattr(self[objkey], fieldname)).lower()
                                    # check if constrained field contains all the values specified in the citation
                                    for val in values:
                                        string.index(fieldvalue, val)
                            else:
                                # we get here only when all constraints are satisfied
                                if match != None:
                                    self.error("crosstex: citation constraint %s is ambiguous, both %s and %s match" % (key, match, objkey))
                                    raise Exception("non-unique constraint citation")
                                match = objkey
				if self[objkey]._citekey == None:
				    self[objkey]._citekey = objkey
                                    self._citations.append(objkey)
                                if objkey != self[objkey]._citekey:
                                    self.error("crosstex: multiply cited object <%s> must be cited under the same key or alias in all citations (attempted to cite it as %s)" % (self[objkey]._citekey, objkey))
                        except Exception, e:
                            if str(e) == "non-unique constraint citation":
                                break
                else:
                    if key in self:
                        if hasattr(self[key], '_label'):
			    if self[key]._citekey == None:
				self[key]._citekey = key
				self._citations.append(key)
			    if key != self[key]._citekey:
				self.error("crosstex: multiply cited object <%s> must be cited under the same key or alias in all citations (attempted to cite it as %s)" % (self[key]._citekey, key))
                        else:
                            self.warning("crosstex: %s %s is not citeable" % (self[key]._name, key))
                    else:
                        self.error("crosstex: citation for nonexistant key %s" % key)

	for reverse, field in self.options.sort:
	    def keyfunc(x):
		try:
		    if field == 'label':
			return self[x]._label()
		    elif field == 'citation':
			return self._citations.index(x)
		    else:
			return tryint(getattr(self[x], field))
		except:
		    return ''
	    citelist = copy.copy(self._citations)
	    if reverse:
		citelist.reverse()
	    sorted = [ (keyfunc(citation), i, citation) for i, citation in enumerate(citelist) ]
	    sorted.sort()
	    if reverse:
		sorted.reverse()
	    self._citations = [ citation for _, _, citation in sorted ]

	return self._citations

    def divide(self, list=[], heading=-1):
	if self.options.headinglevel + heading < 0:
	    return {'': list}
	results = {}
	for cite in list:
	    key = ''
	    if hasattr(self[cite], self.options.heading[heading][1]):
		key = tryint(getattr(self[cite], self.options.heading[heading][1]))
	    results.setdefault(key, []).append(cite)
	if self.options.headinglevel + heading > 0:
	    for key in results:
		results[key] = self.divide(results[key], heading - 1)
	return results

    def addobject(self, name, keys, data, defaults, file, line):
        name = name.strip().lower()
	obj = None
        try:
            obj = getattr(crosstexobjects, name)(file, line, self)
        except AttributeError:
	    raise KeyError, "object type %s is not defined" % (name)
	obj._citekey = None
	obj._primarykey = None

	for condition, fields in data:
	    for key in fields:
		try:
		    obj._assign(key, fields[key], condition)
		except ValueError, details:
		    self.warning("%s:%d: %s" % (file, line, details))
	for key in defaults:
	    try:
		obj._assign(key, defaults[key], {}, True)
	    except ValueError, details:
		pass
	obj._resolve()

	for key in keys:
	    if key in self:
		other = self[key]
		if other._fields == obj._fields and other._name == obj._name and [getattr(other, x) for x in other._fields] == [getattr(obj, x) for x in obj._fields]:
		    raise Warning, "re-definition of %s %s at %s:%d" % (obj._name, key, other._file, other._line)
		else:
		    raise KeyError, "%s %s is already defined at %s:%d" % (obj._name, key, other._file, other._line)
	    else:
		self[key] = obj
		if obj._primarykey == None:
		    obj._primarykey = key
		    self.primarykeys += [key]
		self.aliases[key] = obj._primarykey
	return obj

    def extendobject(self, keys, data, defaults, file, line):
	base = None
	for key in keys:
	    if key in self:
		if base != None and base != self[key]:
		    raise KeyError, "aliases do not refer to a single object"
		base = self[key]
	if base == None:
	    raise KeyError, "no object found to extend"

	obj = getattr(crosstexobjects, base._name)(base._file, base._line, self)
	obj._citekey = base._citekey
	obj._primarykey = base._primarykey
	
	for condition, fields in data:
	    for key in fields:
		try:
		    obj._assign(key, fields[key], condition)
		except ValueError, details:
		    self.warning("%s:%d: %s" % (file, line, details))
	for key, value, condition in base._conditionals:
	    try:
		obj._assign(key, value, condition)
	    except ValueError, details:
		pass
	for key in defaults:
	    try:
		obj._assign(key, defaults[key], {}, True)
	    except ValueError, details:
		pass
	obj._resolve(base)
	
	for key in keys:
	    self[key] = obj
	return obj

    def error(self, message):
	if self.options.check > 0:
	    self.errors += 1
	    sys.stderr.write(str(message) + "\n")

    def warning(self, message):
	if self.options.check > 1:
	    self.errors += 1
	    sys.stderr.write(str(message) + "\n")

# Lexer

# Tokens
tokens = (
    'AT', 'COMMA', 'SHARP', 'OPENBRACE', 'CLOSEBRACE', 'LBRACK', 'RBRACK', 'EQUALS', 
    'ATINCLUDE', 'ATSTRING', 'ATEXTEND', 'ATPREAMBLE', 'ATCOMMENT', 'ATDEFAULT', 'ATTITLEPHRASE', 'ATTITLESMALL',
    'NUMBER', 'NAME', 'STRING',
    )

def t_COMMENT(t):
    r'\%.*'
    pass
    # No return value. Token discarded

def t_ATINCLUDE(t):
    r'@[iI][nN][cC][lL][uU][dD][eE]'
    t.lexer.followsequals = 0
    return t
    
def t_ATSTRING(t):
    r'@[sS][tT][rR][iI][nN][gG]'
    t.lexer.followsequals = 0
    return t

def t_ATEXTEND(t):
    r'@[eE][xX][tT][eE][nN][dD]'
    t.lexer.followsequals = 0
    return t
    
def t_ATPREAMBLE(t):
    r'@[pP][rR][eE][aA][mM][bB][lL][eE]'
    t.lexer.followsequals = 0
    return t

def t_ATCOMMENT(t):
    r'@[Cc][Oo][Mm][Mm][Ee][Nn][Tt]'
    t.lexer.followsequals = 1
    return t

def t_ATDEFAULT(t):
    r'@[Dd][Ee][Ff][Aa][Uu][Ll][Tt]'
    t.lexer.followsequals = 0
    return t

def t_ATTITLEPHRASE(t):
    r'@[Tt][Ii][Tt][Ll][Ee][Pp][Hh][Rr][Aa][Ss][Ee]'
    t.lexer.followsequals = 1
    return t

def t_ATTITLESMALL(t):
    r'@[Tt][Ii][Tt][Ll][Ee][Ss][Mm][Aa][Ll][Ll]'
    t.lexer.followsequals = 1
    return t
    
def t_NUMBER(t):
    r'\d+'
    t.lexer.followsequals = 1
    return t

def t_STRING(t):
    r'"(\\.|[^\\"])*"'
    if t.value.count("{") != t.value.count("}"):
        t.lexer.bib.error("%s:%d: mismatched braces in string" % (t.lexer.file, t.lexer.lineno))
    t.lexer.followsequals = 0
    for i in re.finditer('\r\n|\r|\n', t.value):
	t.lexer.lineno += 1
    t.value = t.value[1:-1]
    return t

def t_EQUALS(t):
    r'='
    t.lexer.followsequals = 1
    return t

def t_OPENBRACE(t):
    r'\{'
    # if the open brace is a value, treat it like a string
    if t.lexer.followsequals == 1:
        bracelevel = 1
        # add a char at a time until we have a matching brace
        while bracelevel > 0:
            c = t.lexer.lexdata[t.lexer.lexpos]
            t.lexer.lexpos += 1
            if c == "{" and t.value[-1] != "\\":
                bracelevel += 1
            if c == "}" and t.value[-1] != "\\":
                bracelevel -= 1
            t.value += c
        t.lexer.followsequals = 0
	for i in re.finditer('\r\n|\r|\n', t.value):
	    t.lexer.lineno += 1
	t.value = t.value[1:-1]
	if re.compile('\d+').match(t.value):
            t.type = "NUMBER"
	else:
	    t.type = "STRING"
    return t

def t_CLOSEBRACE(t):
    r'\}'
    t.lexer.followsequals = 0
    return t

def t_AT(t):
    r'@'
    t.lexer.followsequals = 0
    return t
    
def t_SHARP(t):
    r'\#'
    t.lexer.followsequals = 0
    return t
    
def t_COMMA(t):
    r','
    t.lexer.followsequals = 0
    return t

def t_LBRACK(t):
    r'\['
    t.lexer.followsequals = 0
    return t

def t_RBRACK(t):
    r'\]'
    t.lexer.followsequals = 0
    return t

def t_NAME(t):
    r'[a-zA-Z_][-a-zA-Z:0-9/_]*'
    t.lexer.followsequals = 0
    return t

# Ignored characters
t_ignore = " \t"

def t_newline(t):
    r'(\r\n|\r|\n)'
    t.lexer.lineno += 1

def t_error(t):
    t.lexer.bib.error("%s:%d: syntax error at '%s'" % (t.lexer.file, t.lexer.lineno, t.value[0]))
    t.skip(1)
    
# Grammar

# Parsing rules
precedence = ( )

def p_stmt_singleton(t):
    'stmts : stmt'
    pass

def p_stmt_multiple(t):
    'stmts : stmt stmts'
    pass

def p_stmt_include(t):
    'stmt : ATINCLUDE NAME'
    filename = t[2]
    try:
        processfile(filename, t.lexer.bib, ['.xtx', '.bib', '.aux'])
    except Exception, detail:
	t.lexer.bib.error("%s:%d: %s" % (t.lexer.file, t.lineno(2), detail))

def p_stmt_preamble(t):
    'stmt : ATPREAMBLE OPENBRACE STRING CLOSEBRACE'
    t.lexer.bib.preambles += [t[3]]

def p_stmt_comment(t):
    'stmt : ATCOMMENT STRING'
    pass

def p_stmt_default(t):
    'stmt : ATDEFAULT field'
    for key in t[2]:
	if t[2][key] == '':
	    try:
	        del t.lexer.defaults[key]
	    except KeyError:
		pass
	else:
	    t.lexer.defaults[key] = t[2][key]

def p_stmt_titlephrase(t):
    'stmt : ATTITLEPHRASE STRING'
    t.lexer.bib.addtitlephrase(t[2])

def p_stmt_titlesmall(t):
    'stmt : ATTITLESMALL STRING'
    t.lexer.bib.addtitlesmall(t[2])

def p_stmt_string(t):
    'stmt : ATSTRING OPENBRACE fields CLOSEBRACE'
    for key in t[3]:
	try:
	    t.lexer.bib.addobject('string', [key], [({}, {'name': t[3][key]})], t.lexer.defaults, t.lexer.file, t.lineno(3))._check()
	except Warning, detail:
	    t.lexer.bib.warning("%s:%d: %s" % (t.lexer.file, t.lineno(3), detail))
	except Exception, detail:
	    t.lexer.bib.error("%s:%d: %s" % (t.lexer.file, t.lineno(3), detail))

def p_stmt_object(t):
    'stmt : object'
    t[0] = t[1]

def p_object_defn(t):
    'object : AT NAME OPENBRACE keys COMMA fields conditionals CLOSEBRACE'
    t[2] = t[2].lower()
    try:
        t.lexer.bib.addobject(t[2], t[4], [({}, t[6])] + t[7], t.lexer.defaults, t.lexer.file, t.lineno(2))._check()
    except Warning, detail:
	t.lexer.bib.warning("%s:%d: %s" % (t.lexer.file, t.lineno(2), detail))
    except Exception, detail:
	t.lexer.bib.error("%s:%d: %s" % (t.lexer.file, t.lineno(2), detail))

def p_object_extension(t):
    'object : ATEXTEND OPENBRACE keys COMMA fields conditionals CLOSEBRACE'
    try:
        t.lexer.bib.extendobject(t[3], [({}, t[5])] + t[6], t.lexer.defaults, t.lexer.file, t.lineno(1))
    except Warning, detail:
	t.lexer.bib.warning("%s:%d: %s" % (t.lexer.file, t.lineno(1), detail))
    except Exception, detail:
	t.lexer.bib.error("%s:%d: %s" % (t.lexer.file, t.lineno(1), detail))

def p_object_extension_empty(t):
    'object : ATEXTEND OPENBRACE keys CLOSEBRACE'
    try:
        t.lexer.bib.extendobject(t[3], [], t.lexer.defaults, t.lexer.file, t.lineno(1))
    except Warning, detail:
	t.lexer.bib.warning("%s:%d: %s" % (t.lexer.file, t.lineno(1), detail))
    except Exception, detail:
	t.lexer.bib.error("%s:%d: %s" % (t.lexer.file, t.lineno(1), detail))

def p_object_error(t):
    'object : error CLOSEBRACE'
    pass

def p_keys_singleton(t):
    'keys : NAME'
    t[0] = [t[1]]

def p_keys_multiple(t):
    'keys : NAME EQUALS keys'
    t[0] = [t[1]] + t[3]

def p_conditionals_empty(t):
    'conditionals :'
    t[0] = []

def p_conditionals_singleton(t):
    'conditionals : conditional'
    t[0] = [t[1]]

def p_conditionals_multiple(t):
    'conditionals : conditional conditionals'
    t[0] = [t[1]] + t[2]

def p_conditional(t):
    'conditional : LBRACK fields RBRACK fields'
    t[0] = (t[2], t[4])

def p_fields_empty(t):
    'fields :'
    t[0] = []

def p_fields_singleton(t):
    'fields : field'
    t[0] = t[1]

def p_fields(t):
    'fields : field COMMA fields'
    t[0] = t[1]
    for key in t[3]:
	t[0][key] = t[3][key]
              
def p_field(t):
    'field : NAME EQUALS value'
    t[1] = t[1].lower()
    if t[1] == 'author' or t[1] == 'editor':
	values = crosstexobjects.authorlist(t.lexer.bib.options)
	if isinstance(t[3], str):
	    for key in re.compile('\s+and\s+').split(t[3]):
		if key in t.lexer.bib:
		    values += [t.lexer.bib[key]]
		else:
		    try:
			t.lexer.bib.addobject('author', [key], [({}, {'name': key})], t.lexer.defaults, t.lexer.file, t.lineno(3))._check()
			values += [t.lexer.bib[key]]
		    except Warning, detail:
			t.lexer.bib.warning("%s:%d: %s" % (t.lexer.file, t.lineno(3), detail))
		    except Exception, detail:
			t.lexer.bib.error("%s:%d: %s" % (t.lexer.file, t.lineno(3), detail))
			raise
	else:
	    values += [t[3]]
	t[0] = {t[1]: values}
    else:
	t[0] = {t[1]: t[3]}

def p_value_singleton(t):
    'value : simplevalue'
    t[0] = t[1]

def p_value_concat(t):
    'value : value SHARP simplevalue'
    t[0] = t[1].rstrip("\"") + t[3].lstrip("\"")

def p_simplevalue_number(t):
    'simplevalue : NUMBER'
    t[0] = t[1]
    
def p_simplevalue_name(t):
    'simplevalue : NAME'
    t[0] = crosstexobjects.objref(t[1], t.lexer.bib)
    try:
	strval = str(t[0].value())
    except KeyError:
	t.lexer.bib.warning("%s:%d: reference to undefined object '%s', using it as a string" % (t.lexer.file, t.lineno(1), t[1]))
	t[0] = t[1]
    
def p_simplevalue_string(t):
    'simplevalue : STRING'
    t[0] = t[1]

def p_error(t):
    t.lexer.bib.error("%s:%d: parse error at '%s'" % (t.lexer.file, t.lexer.lineno, t.value[0]))

def processfile(infilename, bib, exts=['.aux', '.xtx', '.bib']):
    if infilename in bib.seenfiles:
	if 'file' in bib.options.dump:
            sys.stderr.write("File %s already processed, skipping.\n" % infilename)
	return infilename

    names = []
    if infilename[infilename.rfind('.'):] in exts:
	names = [infilename]
    else:
	names = [infilename + ext for ext in exts]

    paths = []
    if infilename[0] == '/':
	paths = names
    else:
	for name in names:
	    if bib.location:
	        paths.append('/'.join([bib.location[-1], name]))
	    paths.extend(['/'.join([path, name]) for path in bib.options.dir])

    for filename in paths:
	try:
	    instream = open(filename, 'r')
	    if 'file' in bib.options.dump:
		sys.stderr.write("Processing %s...\n" % filename)
	    bib.location.append(filename[0:filename.rfind("/")])
	    if filename.endswith('.aux'):
		parseaux(instream, bib)
	    else:
		parsextx(instream, infilename, bib)
	    bib.location.pop()
	    instream.close()
	    bib.seenfiles.append(infilename)
	    return filename
	except IOError:
	    continue
    else:
        raise IOError, '%s does not exist or is not a bibliographic database' % infilename

def parseaux(instream, bib):
    options = []
    datafiles = []
    while 1:
        line = instream.readline()
        if not line:
            break
        if line[0:9] == "\\citation":
            citeline = line[10:].strip().rstrip("}")
            for cite in citeline.split(","):
                if cite.find(" ") >= 0:
                    bib.error("citation with empty space \"%s\"" % cite)
                else:
		    cite = cite.strip(", 	")
		    if cite == "":
			bib.error("empty citation, check for spurious commas in \\cite{} commands")
		    else:
			options.extend(['--cite', cite])
        elif line[0:9] == "\\bibstyle":
	    options.extend(['--style'] + line[10:].rstrip().rstrip("}").split(' '))
        elif line[0:8] == "\\bibdata":
            datafiles.extend(line[9:].rstrip().rstrip("}").split(','))
    bib.setoptions(options)
    for datafile in datafiles:
	try:
	    processfile(datafile, bib, ['.xtx', '.bib', '.aux'])
	except Exception, details:
	    bib.error("Could not process data file %s: %s" % (datafile, details))
    
def parsextx(instream, infilename, bib):
    lexer = lex.lex()
    lexer.bib = bib
    lexer.file = infilename
    lexer.lineno = 1
    lexer.followsequals = 0
    lexer.defaults = {}
    parser = yacc.yacc(debug=0, write_tables=0) # set these to 1 for icky debugging
    parser.parse(instream.read(), lexer=lexer)


namearg = '--' + sys.argv[0].split('/')[-1]
if optparser.has_option(namearg):
    sys.argv.insert(1, namearg)

startbib = bibliography()
args = startbib.setoptions(sys.argv[1:])
if len(args) == 0:
    optparser.print_help()
    sys.exit(0)

errors = 0
for infilename in args:
    # Use a different environment for each file.
    bib = bibliography()
    bib.setoptions(sys.argv[1:])
    
    # Include standard databases.
    try:
	processfile('standard', bib)
    except:
	pass

    # Parse the file.
    outfile = None
    filename = None
    try:
	filename = processfile(infilename, bib)
	outfilename = filename[:filename.rfind('.') + 1] + bib.options.convert
	if outfilename == filename:
	    outfilename += '.new'
	try:
	    if bib.options.convert == 'html':
		t = pipes.Template()
		t.append('hevea -O', '--')
		outfile = t.open(outfilename, 'w')
	    else:
		outfile = open(outfilename, 'w')
	except:
	    raise IOError, "unable to open output file %s" % outfilename
    except Exception, details:
	bib.error("crosstex: unable to process file %s: %s" % (infilename, details))
	continue

    if len(bib.options.cite) == 0 and not filename.endswith('.aux'):
	bib.setoptions(['--cite', '*'])

    # Handle dump-locations, dump-conferences, etc.
    for objtype in bib.options.dump:
	objs = [ "%s\t%s\n" % (key, bib[key]) for key in bib.primarykeys if hasattr(crosstexobjects, objtype) and isinstance(bib[key], getattr(crosstexobjects, objtype)) ]
	if len(objs) != 0:
	    sys.stderr.write("%s\n" % (objtype.upper() + ':'))
	    for i in objs:
	        sys.stderr.write(i)
    if 'titlephrase' in bib.options.dump:
        sys.stderr.write("TITLE PHRASES:\n")
        for phrase in bib.titlephrases.values():
            sys.stderr.write("%s\n" % phrase)
        sys.stderr.write("TITLE SMALL WORDS:\n")
        for small in bib.titlesmall:
            sys.stderr.write("%s\n" % small)

    # Print headers required by output format.
    if bib.options.convert == 'bib' or bib.options.convert == 'xtx':
	for i in bib.preambles:
	    outfile.write("@PREAMBLE { \"" + i + "\" }\n\n")
    if bib.options.convert == 'html':
	outfile.write("\\documentclass{report}\n")
	outfile.write("\\usepackage{hyperref}\n")
	outfile.write("\\begin{document}\n")
    if bib.options.convert == 'html' or bib.options.convert == 'bbl':
	for i in bib.preambles:
	    outfile.write(i)
	    outfile.write("\n")
	if bib.options.blank_labels:
	    outfile.write("\\makeatletter\\def\\@biblabel#1{}\\makeatother\n")
        if bib.options.break_lines:
	    outfile.write("\\renewcommand{\\newblock}{\\\\}")
	outfile.write("\\newcommand{\\etalchar}[1]{$^{#1}$}\n")

    # Determine the space to allocate for labels
    def maxstr(citations, bib):
	if citations:
	    maxstr = ''
	    for key in citations:
		citekey = bib[key]._label().replace("{\\etalchar{+}}", "X")
		if len(citekey) > len(maxstr):
		    maxstr = citekey
	    strlen = int(math.ceil(math.log(len(citations), 10)))
	    if maxstr == '':
		return '0' * strlen
	    elif len(maxstr) >= 13:
		return 'X' * 13
	return 'X'

    # Display a hierarchal bibliography in categories
    def writecategories(categories, bib, outfile):
	if isinstance(categories, list):
	    for key in categories:
		outfile.write(str(bib[key]))
	elif isinstance(categories, dict):
	    headings = categories.keys()
	    headings.sort()
	    if len(bib.options.heading) and bib.options.heading[-bib.options.headingdepth-1][0]:
		headings.reverse()
	    for heading in headings:
		if bib.options.convert == 'html' or bib.options.convert == 'bbl':
		    if heading != '':
			outfile.write("{\\renewcommand{\\refname}{%s}\n" % heading)
		    outfile.write("\\begin{thebibliography}{" + maxstr(categories[heading], bib) + "}\n")
		if bib.options.convert == 'xtx' and len(bib.options.heading):
		    outfile.write("@default " + crosstexobjects.fieldval(bib.options.heading[-bib.options.headingdepth-1][1], heading) + "\n\n")
	        bib.options.headingdepth += 1
		writecategories(categories[heading], bib, outfile)
	        bib.options.headingdepth -= 1
		if bib.options.convert == 'html' or bib.options.convert == 'bbl':
		    if heading != '':
			outfile.write("\\end{thebibliography}}\n")
		    else:
			outfile.write("\\end{thebibliography}\n")

    # Format each titled section.
    if bib.options.convert != 'xtx' and bib.options.headinglevel > 1:
	bib.options.headinglevel = 1
    citations = bib.citations()
    divided = bib.divide(citations)
    writecategories(divided, bib, outfile)

    # Print footers required by output format.
    if bib.options.convert == 'html':
	outfile.write("\\end{document}\n")
    outfile.close()

    errors += bib.errors

sys.exit(errors)
